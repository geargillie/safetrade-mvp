// Install AWS SDK
// npm install aws-sdk

// app/api/verify-id-textract/route.ts
import { NextRequest, NextResponse } from 'next/server';
import AWS from 'aws-sdk';
import { createClient } from '@supabase/supabase-js';

// Configure AWS
AWS.config.update({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION || 'us-east-1'
});

const textract = new AWS.Textract();
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Extract data from government ID using AWS Textract
async function extractIDData(imageBase64: string) {
  try {
    // Convert base64 to buffer
    const imageBuffer = Buffer.from(imageBase64.split(',')[1], 'base64');
    
    // Use Textract AnalyzeID API (specifically for IDs)
    const params = {
      Document: {
        Bytes: imageBuffer
      }
    };

    const result = await textract.analyzeID(params).promise();
    
    // Extract key-value pairs from the ID
    const extractedData: any = {};
    
    if (result.IdentityDocuments && result.IdentityDocuments[0]) {
      const document = result.IdentityDocuments[0];
      
      // Extract identity document fields
      document.IdentityDocumentFields?.forEach((field) => {
        const type = field.Type?.Text;
        const value = field.ValueDetection?.Text;
        
        if (type && value) {
          switch (type.toLowerCase()) {
            case 'first_name':
              extractedData.firstName = value;
              break;
            case 'last_name':
              extractedData.lastName = value;
              break;
            case 'date_of_birth':
              extractedData.dateOfBirth = value;
              break;
            case 'document_number':
              extractedData.documentNumber = value;
              break;
            case 'expiration_date':
              extractedData.expirationDate = value;
              break;
            case 'address':
              extractedData.address = value;
              break;
            case 'state':
              extractedData.state = value;
              break;
          }
        }
      });
    }

    // Calculate confidence score
    const confidence = result.IdentityDocuments?.[0]?.IdentityDocumentFields?.reduce((avg, field) => {
      return avg + (field.ValueDetection?.Confidence || 0);
    }, 0) / (result.IdentityDocuments?.[0]?.IdentityDocumentFields?.length || 1) || 0;

    return {
      success: true,
      extractedData,
      confidence: confidence / 100, // Convert to 0-1 scale
      documentType: 'government_id',
      awsMetadata: {
        documentCount: result.IdentityDocuments?.length || 0,
        fieldsExtracted: Object.keys(extractedData).length
      }
    };

  } catch (error: any) {
    console.error('AWS Textract error:', error);
    return {
      success: false,
      error: error.message,
      extractedData: {},
      confidence: 0
    };
  }
}

// Validate extracted ID data
function validateIDData(extractedData: any, confidence: number) {
  const validations = {
    hasFirstName: !!extractedData.firstName,
    hasLastName: !!extractedData.lastName,
    hasDateOfBirth: !!extractedData.dateOfBirth,
    hasDocumentNumber: !!extractedData.documentNumber,
    goodConfidence: confidence > 0.7,
    notExpired: true // Would check expiration date
  };

  const passedChecks = Object.values(validations).filter(Boolean).length;
  const score = Math.round((passedChecks / Object.keys(validations).length) * 100);

  return {
    isValid: score >= 70 && confidence > 0.7,
    score,
    validations,
    confidence: Math.round(confidence * 100)
  };
}

export async function POST(request: NextRequest) {
  try {
    const { userId, documentImage, timestamp } = await request.json();

    if (!userId || !documentImage) {
      return NextResponse.json(
        { error: 'Missing required verification data' },
        { status: 400 }
      );
    }

    // Extract data using AWS Textract
    const extractionResult = await extractIDData(documentImage);
    
    if (!extractionResult.success) {
      return NextResponse.json(
        { error: 'Failed to process document: ' + extractionResult.error },
        { status: 400 }
      );
    }

    // Validate the extracted data
    const validation = validateIDData(extractionResult.extractedData, extractionResult.confidence);
    
    // Store verification record
    const { data: verificationRecord, error: insertError } = await supabase
      .from('identity_verifications')
      .insert({
        user_id: userId,
        onfido_applicant_id: `textract_${userId}_${Date.now()}`,
        status: validation.isValid ? 'verified' : 'failed',
        onfido_result: validation.isValid ? 'clear' : 'consider',
        verification_data: {
          method: 'aws_textract',
          extractedData: extractionResult.extractedData,
          confidence: validation.confidence,
          score: validation.score,
          validations: validation.validations,
          awsMetadata: extractionResult.awsMetadata,
          timestamp: timestamp
        },
        created_at: new Date().toISOString(),
        completed_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (insertError) {
      console.error('Failed to store verification record:', insertError);
      return NextResponse.json(
        { error: 'Failed to save verification results' },
        { status: 500 }
      );
    }

    // Update user verification status if verified
    if (validation.isValid) {
      const { error: updateUserError } = await supabase
        .from('user_profiles')
        .update({
          identity_verified: true,
          verification_level: 'aws_textract_id',
          verified_at: new Date().toISOString()
        })
        .eq('id', userId);

      if (updateUserError) {
        console.error('Failed to update user verification status:', updateUserError);
      }
    }

    return NextResponse.json({
      verified: validation.isValid,
      score: validation.score,
      confidence: validation.confidence,
      message: validation.isValid 
        ? 'Government ID verification successful!'
        : 'Government ID verification failed. Please ensure your document is clear and try again.',
      extractedData: {
        firstName: extractionResult.extractedData.firstName,
        lastName: extractionResult.extractedData.lastName,
        state: extractionResult.extractedData.state,
        // Don't return sensitive data like full document number
      },
      validations: validation.validations,
      verificationId: verificationRecord.id
    });

  } catch (error) {
    console.error('Textract verification error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
