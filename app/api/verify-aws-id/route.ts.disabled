import { NextRequest, NextResponse } from 'next/server';
import { TextractClient, AnalyzeIDCommand } from '@aws-sdk/client-textract';
import { createClient } from '@supabase/supabase-js';

// Helper function to get Supabase client
function getSupabaseClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    throw new Error('Missing Supabase environment variables');
  }

  return createClient(supabaseUrl, supabaseServiceKey);
}

// Initialize AWS Textract client
const textractClient = new TextractClient({
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  },
});

// Extract data from government ID using AWS Textract
async function extractIDWithTextract(imageBase64: string) {
  try {
    // Convert base64 to buffer (remove data:image/jpeg;base64, prefix)
    const base64Data = imageBase64.includes(',') ? imageBase64.split(',')[1] : imageBase64;
    const imageBuffer = Buffer.from(base64Data, 'base64');
    
    // Use Textract AnalyzeID command (correct AWS SDK v3 syntax)
    const command = new AnalyzeIDCommand({
      DocumentPages: [
        {
          Bytes: new Uint8Array(imageBuffer)
        }
      ]
    });

    const result = await textractClient.send(command);
    
    // Extract key-value pairs from the ID
    const extractedData: any = {};
    let totalConfidence = 0;
    let fieldCount = 0;
    
    if (result.IdentityDocuments && result.IdentityDocuments[0]) {
      const document = result.IdentityDocuments[0];
      
      // Extract identity document fields
      document.IdentityDocumentFields?.forEach((field) => {
        const type = field.Type?.Text;
        const value = field.ValueDetection?.Text;
        const confidence = field.ValueDetection?.Confidence || 0;
        
        if (type && value) {
          fieldCount++;
          totalConfidence += confidence;
          
          // Map AWS field types to our schema
          switch (type.toLowerCase()) {
            case 'first_name':
              extractedData.firstName = value;
              break;
            case 'last_name':
            case 'surname':
              extractedData.lastName = value;
              break;
            case 'middle_name':
              extractedData.middleName = value;
              break;
            case 'date_of_birth':
            case 'dob':
              extractedData.dateOfBirth = value;
              break;
            case 'id_number':
            case 'document_number':
            case 'license_number':
              extractedData.documentNumber = value;
              break;
            case 'expiration_date':
            case 'exp_date':
              extractedData.expirationDate = value;
              break;
            case 'address':
            case 'address_line_1':
              extractedData.address = value;
              break;
            case 'city':
              extractedData.city = value;
              break;
            case 'state':
            case 'state_code':
              extractedData.state = value;
              break;
            case 'zip_code':
            case 'postal_code':
              extractedData.zipCode = value;
              break;
            case 'country':
              extractedData.country = value;
              break;
            case 'sex':
            case 'gender':
              extractedData.gender = value;
              break;
            case 'height':
              extractedData.height = value;
              break;
            case 'weight':
              extractedData.weight = value;
              break;
            case 'eye_color':
              extractedData.eyeColor = value;
              break;
            case 'document_type':
              extractedData.documentType = value;
              break;
          }
        }
      });
    }

    // Calculate average confidence
    const averageConfidence = fieldCount > 0 ? totalConfidence / fieldCount : 0;

    return {
      success: true,
      extractedData,
      confidence: averageConfidence / 100, // Convert to 0-1 scale
      fieldsExtracted: fieldCount,
      documentType: extractedData.documentType || 'government_id',
      awsResponse: {
        documentCount: result.IdentityDocuments?.length || 0,
        fieldsFound: fieldCount
      }
    };

  } catch (error: any) {
    console.error('AWS Textract error:', error);
    return {
      success: false,
      error: error.message || 'Unknown AWS Textract error',
      extractedData: {},
      confidence: 0,
      fieldsExtracted: 0
    };
  }
}

// Validate extracted ID data and calculate verification score
function validateExtractedData(extractedData: any, confidence: number, fieldsExtracted: number) {
  const validations = {
    hasName: !!(extractedData.firstName && extractedData.lastName),
    hasDateOfBirth: !!extractedData.dateOfBirth,
    hasDocumentNumber: !!extractedData.documentNumber,
    hasAddress: !!(extractedData.address || extractedData.city),
    hasState: !!extractedData.state,
    goodConfidence: confidence > 0.7,
    sufficientFields: fieldsExtracted >= 4,
    notExpired: true // TODO: Implement expiration date checking
  };

  // Check if document is expired
  if (extractedData.expirationDate) {
    try {
      const expDate = new Date(extractedData.expirationDate);
      const today = new Date();
      validations.notExpired = expDate > today;
    } catch (e) {
      // If date parsing fails, assume not expired
      validations.notExpired = true;
    }
  }

  const passedChecks = Object.values(validations).filter(Boolean).length;
  const totalChecks = Object.keys(validations).length;
  const score = Math.round((passedChecks / totalChecks) * 100);

  // Require minimum score and confidence for verification
  const isValid = score >= 75 && confidence > 0.65 && fieldsExtracted >= 3;

  return {
    isValid,
    score,
    validations,
    confidence: Math.round(confidence * 100),
    passedChecks,
    totalChecks
  };
}

export async function POST(request: NextRequest) {
  try {
    // Get Supabase client with error handling
    let supabase;
    try {
      supabase = getSupabaseClient();
    } catch (error) {
      console.error('Supabase initialization error:', error);
      return NextResponse.json(
        { error: 'Server configuration error' },
        { status: 500 }
      );
    }

    const { userId, documentImage, timestamp } = await request.json();

    if (!userId || !documentImage) {
      return NextResponse.json(
        { error: 'Missing required verification data' },
        { status: 400 }
      );
    }

    // Validate AWS credentials
    if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY) {
      return NextResponse.json(
        { error: 'AWS credentials not configured' },
        { status: 500 }
      );
    }

    // Extract data using AWS Textract
    const extractionResult = await extractIDWithTextract(documentImage);
    
    if (!extractionResult.success) {
      return NextResponse.json(
        { 
          error: 'Failed to process document with AWS Textract',
          details: extractionResult.error 
        },
        { status: 400 }
      );
    }

    // Validate the extracted data
    const validation = validateExtractedData(
      extractionResult.extractedData, 
      extractionResult.confidence,
      extractionResult.fieldsExtracted
    );
    
    // Store verification record
    const { data: verificationRecord, error: insertError } = await supabase
      .from('identity_verifications')
      .insert({
        user_id: userId,
        onfido_applicant_id: `aws_textract_${userId}_${Date.now()}`,
        status: validation.isValid ? 'verified' : 'failed',
        onfido_result: validation.isValid ? 'clear' : 'consider',
        verification_data: {
          method: 'aws_textract_professional',
          extractedData: extractionResult.extractedData,
          confidence: validation.confidence,
          score: validation.score,
          validations: validation.validations,
          fieldsExtracted: extractionResult.fieldsExtracted,
          awsResponse: extractionResult.awsResponse,
          timestamp: timestamp
        },
        created_at: new Date().toISOString(),
        completed_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (insertError) {
      console.error('Failed to store verification record:', insertError);
      return NextResponse.json(
        { error: 'Failed to save verification results' },
        { status: 500 }
      );
    }

    // Update user verification status if verified
    if (validation.isValid) {
      const { error: updateUserError } = await supabase
        .from('user_profiles')
        .update({
          identity_verified: true,
          verification_level: 'aws_textract_professional',
          verified_at: new Date().toISOString()
        })
        .eq('id', userId);

      if (updateUserError) {
        console.error('Failed to update user verification status:', updateUserError);
        // Don't fail the request, just log the error
      }
    }

    // Return verification results (sanitized for security)
    return NextResponse.json({
      verified: validation.isValid,
      score: validation.score,
      confidence: validation.confidence,
      fieldsExtracted: extractionResult.fieldsExtracted,
      message: validation.isValid 
        ? 'Government ID verification successful! Your identity has been verified using AWS Textract.'
        : `Verification failed. Score: ${validation.score}/100, Confidence: ${validation.confidence}%. Please ensure your ID is clear and try again.`,
      extractedData: {
        // Return non-sensitive extracted data
        firstName: extractionResult.extractedData.firstName,
        lastName: extractionResult.extractedData.lastName,
        state: extractionResult.extractedData.state,
        documentType: extractionResult.extractedData.documentType,
        // Don't return sensitive data like full document number, address, DOB
      },
      validations: validation.validations,
      verificationId: verificationRecord.id,
      provider: 'AWS Textract Professional'
    });

  } catch (error: any) {
    console.error('AWS Textract verification error:', error);
    return NextResponse.json(
      { 
        error: 'Internal server error during verification',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      },
      { status: 500 }
    );
  }
}
